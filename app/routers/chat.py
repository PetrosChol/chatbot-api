import logging
from fastapi import APIRouter, Depends, HTTPException, status, Body
from typing import Optional
from pydantic import BaseModel, Field
import redis.asyncio as redis
from sqlalchemy.ext.asyncio import AsyncSession

from app.services.chat_service import process_chat_message
from app.db.session import get_session
from app.memory.client import get_redis
from fastapi_limiter.depends import RateLimiter

logger = logging.getLogger(__name__)

router = APIRouter()

# --- Request and Response Models ---


class ChatRequest(BaseModel):
    user_message: str = Field(..., description="The message sent by the user.")
    session_id: Optional[str] = Field(
        default=None,
        description="Optional session ID to maintain conversation context.",
    )


class ChatResponse(BaseModel):
    bot_reply: str = Field(..., description="The response generated by the chatbot.")
    session_id: str = Field(
        ..., description="The session ID for the conversation (new or existing)."
    )


# --- Chat Endpoint ---


@router.post(
    "/chat",
    response_model=ChatResponse,
    summary="Process a user chat message",
    description="Receives a user message, processes it using the agent logic, "
    "and returns the bot's reply along with the session ID.",
    tags=["Chat"],
    dependencies=[Depends(RateLimiter(times=5, seconds=60))],
)
async def handle_chat_message(
    request_body: ChatRequest = Body(...),
    db: AsyncSession = Depends(get_session),
    redis_client: redis.Redis = Depends(get_redis),
):
    """
    Handles incoming chat messages via POST request.
    """
    logger.info(
        f"Received chat request for session: {request_body.session_id or 'new'}"
    )
    try:
        bot_reply, session_id = await process_chat_message(
            user_message=request_body.user_message,
            session_id=request_body.session_id,
            redis_client=redis_client,
            db=db,
        )
        logger.info(f"Successfully processed chat request for session: {session_id}")
        return ChatResponse(bot_reply=bot_reply, session_id=session_id)

    except HTTPException as http_exc:
        # Re-raise HTTP exceptions (like 503 from dependencies)
        logger.error(
            f"HTTP exception during chat processing: {http_exc.detail}", exc_info=True
        )
        raise http_exc
    except Exception as e:
        # Catch-all for unexpected errors during processing
        logger.error(
            f"Unexpected error processing chat message for session {request_body.session_id or 'new'}: {e}",
            exc_info=True,
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An internal error occurred while processing the message.",
        )
